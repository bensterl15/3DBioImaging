#include "Deconvolution.hpp"

// Comes from Deconvolution/calculateSmallOTF.m
void Deconvolution::calculateSmallOTF() {
	Eigen::DSizes<Eigen::DenseIndex, 3> sizePSF = PSF->dimensions();
	Eigen::DSizes<Eigen::DenseIndex, 4> imageSize = image->dimensions();

	// The saved PSF must be the same size or larger than the images:
	if (sizePSF.at(0) < imageSize.at(0) || sizePSF.at(1) < imageSize.at(1) || sizePSF.at(2) < imageSize.at(2)) {
		cout << "WARNING: The PSF is smaller than the image size in at least one dimension. All images will be cropped" << endl;
		for (uint8_t ind = 0; ind < 3; ind++)
			newImageSize[ind] = min(sizePSF.at(ind), imageSize.at(ind));
	}
	else {
		for (uint8_t ind = 0; ind < 3; ind++)
			newImageSize[ind] = imageSize.at(ind);
	}

	//Find the box of size newImageSize about the PSF origin:
	uint16_t originPSF[3] = { 0, 0, 0 };
	for (uint8_t ind = 0; ind < 3; ind++)
		originPSF[ind] = ceil((sizePSF.at(ind) + 1) / 2);

	// PSF = PSF - min(PSF(:))
	float* dat = PSF->data();
	pair<float*, float*> minmax = minmax_element(dat, dat + sizePSF.at(0) * sizePSF.at(1) * sizePSF.at(2));
	*PSF -= PSF->constant(*(minmax.first));

	// PSF = PSF ./ max(PSF(:))
	*PSF /= PSF->constant(*(minmax.second));

	/*
	smallPSF = PSF( ...
					(originPSF(1)-ceil((newImageSize(1)-1)/2)):(originPSF(1)+floor((newImageSize(1)-1)/2)), ...
					(originPSF(2)-ceil((newImageSize(2)-1)/2)):(originPSF(2)+floor((newImageSize(2)-1)/2)), ...
					(originPSF(3)-ceil((newImageSize(3)-1)/2)):(originPSF(3)+floor((newImageSize(3)-1)/2))
				);
	*/

	Eigen::DSizes<ptrdiff_t, 3> offsets((int)(originPSF[0] - ceil((newImageSize[0] - 1) / 2)) - 1, (int)(originPSF[1] - ceil((newImageSize[1] - 1) / 2)) - 1, (int)(originPSF[2] - ceil((newImageSize[2] - 1) / 2)) - 1);
	Eigen::DSizes<ptrdiff_t, 3> extents((int)(originPSF[0] + floor((newImageSize[0] - 1) / 2)) - 1, (int)(originPSF[1] + floor((newImageSize[1] - 1) / 2)) - 1, (int)(originPSF[2] + floor((newImageSize[2] - 1) / 2)) - 1);
	Slice3D slice(PSF, &offsets, &extents);
	Eigen::Tensor<float, 3, Eigen::RowMajor> smallPSF = slice.result;


	// smallOTF = fftshift(fftn(smallPSF)); clear smallPSF ;
	// smallOTF = abs(smallOTF);
	Eigen::DSizes<Eigen::DenseIndex, 3> sizesmallOTF = smallOTF->dimensions();
	Fourier3D fourier(&smallPSF, smallOTF, sizesmallOTF.at(0), sizesmallOTF.at(1), sizesmallOTF.at(2));
	fourier.compute_abs_fft();
	fourier.abs_fftshift();
}

void Deconvolution::cropToSmallOTF() {
	// originImage = ceil((imageSize + ones(1, 3)) / 2); % (for even sizes the origin occurs above the center, i.e.the origin of an image with size 4x4 occurs at(3, 3))
	Eigen::DSizes<Eigen::DenseIndex, 4> originImage = image->dimensions();
	for (int i = 0; i < 3; i++)
		originImage.at(i) = ceil((originImage.at(i) + 1) / 2);
	// image3D = image3D(
	// (originImage(1) - ceil((newImageSize(1) - 1) / 2)) : (originImage(1) + floor((newImageSize(1) - 1) / 2)), ...
	// (originImage(2) - ceil((newImageSize(2) - 1) / 2)) : (originImage(2) + floor((newImageSize(2) - 1) / 2)), ...
	// (originImage(3) - ceil((newImageSize(3) - 1) / 2)) : (originImage(3) + floor((newImageSize(3) - 1) / 2))
	//  );
	Eigen::DSizes<ptrdiff_t, 4> offsets((int)(originImage.at(0) - ceil((newImageSize[0] - 1) / 2)) - 1, (int)(originImage.at(1) - ceil((newImageSize[1] - 1) / 2)) - 1, (int)(originImage.at(2) - ceil((newImageSize[2] - 1) / 2)) - 1, 0);
	Eigen::DSizes<ptrdiff_t, 4> extents((int)(originImage.at(0) + floor((newImageSize[0] - 1) / 2)) - 1, (int)(originImage.at(1) + floor((newImageSize[1] - 1) / 2)) - 1, (int)(originImage.at(2) + floor((newImageSize[2] - 1) / 2)) - 1, originImage.at(3));
	Slice4D slice(image, &offsets, &extents);
	//free(image);
	image = &(slice.result);
}

void Deconvolution::makeApodizationFilter() {

}

void Deconvolution::weinerDeconvolve() {
	// image3D - The image that will be convolved
	// OTF - an optical transfer function that is the same size as the image
	// weiner - A constant, inverse of SNR
	// apodizeFilter - An apodization filter in Fourier space to remove artifacts generated by deconvolution

	float weiner = 1;

	Eigen::DSizes<Eigen::DenseIndex, 4> dims = image->dimensions();
	Eigen::Tensor<complex<float>, 3, Eigen::RowMajor> fft(512,512,40);// (dims.at(0), dims.at(1), dims.at(2));
	Eigen::Tensor<float, 3, Eigen::RowMajor> image3D(512, 512, 40);
	image3D = image->chip(0, 3);
	Fourier3D fourier(&image3D, &fft, dims.at(0), dims.at(1), dims.at(2));
	for (int z = 0; z < dims.at(3); z++) {
		// Fourier transform the image
		// image3D = fftshift(fftn(image3D));
		fourier.compute_fft();
		fourier.fftshift();

		// perform the Weiner deconvolution
		// image3D = image3D.*OTF. / ((OTF.*OTF) + weiner); clear OTF
		image3D *= *smallOTF;
		Eigen::Tensor<float, 3, Eigen::RowMajor> denom = (*smallOTF) * (*smallOTF) + smallOTF->constant(weiner);
		image3D /= denom;

		// perform apodization
		// image3D = image3D.*apodizeFilter; clear apodizeFilter

		// inverse Fourier transform back to the image domain
		// image3D = ifftn(ifftshift(image3D));

		// take the absolute value of the image
		// image3D = abs(image3D);

		// remove image values less than 0
		// image3D = image3D.*(image3D > 0);
	}
}